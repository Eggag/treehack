[{"name": "Mod Mod Mod", "code": ["889", "E"], "tags": ["binary search", "dp", "math"], "difficulty": 3000, "statement": "You are given a sequence of integers a1, a2, ..., an. Let , and  for 1 \u2264 i < n. Here,  denotes the modulus operation. Find the maximum value of f(x, 1) over all nonnegative integers x. ", "editorial": "Hint 1: let . Can you define some interesting segments of value xi?Hint 2: think of some dp.Hint 3: once you get the dp in O(n2), to speed it up, note the following fact: if , then either c = a or .Explanation of hint 1: let's call ansi = f(x, 1) - f(xi, i + 1), in other words, it's the part of answer we gain from summands from 1 to i. For i = 1 the following is true: x1 can be any number from 0 to a1 - 1, and ansi = xi.Suppose for some i we have the following option: xi can be any number from 0 to r, and in this case ansi = xi * i + k. We can describe this situation by triple (i, r, k). We will show that this triple will produce at most two such triples for i + 1. Indeed, we can have many triples (i + 1, ai + 1 - 1, kj) with different kj and one triple . However, we can note that among triplets of the first type we can leave only one with maximum kj, because we're interested in maximum answer. This kj will equal . Thus, we have two transitions from each triple, that leads us to O(2n) bruteforce solution.Explanation of hint 2: when we have a bruteforce, we (almost) always can think of a dp. Indeed, we have triples, among those with equal i and r let's keep only one with the largest k. There are at most i such triples on step i: on each step half of the generated triples have r = ai + 1 - 1, so we can merge them. This leads us to dp in O(n2).Explanation of hint 3: Okay, what does the third hint say? It basically says that a number can only be taken by modulo  times until it becomes zero, where C is the bound of its initial value. What do we get from this? We can note that if r < ai + 1, we can just leave a triple (i, r, k) untouched except changing i to i + 1. Let's then keep pairs (r, k), assuming triples (i, r, k), where i changes in a cycle. On each step we should change all pairs such that r \u2265 ai + 1, possibly adding one more pair with r = ai + 1 - 1. But when we change a pair, r is get by modulo, so this won't happen with a pair more than O(log(C)) times! Overall, the total number of times we touch a pair is bounded by . Adding  for map in which we keeps the pairs, we obtain the final complexity . Also, map can be replaced with binary search, but the complexity remains the same.", "simplified": {"statement": "\nFind the maximum value of (a1 + a2x) mod n for all nonnegative integers x.", "editorial": "\nGiven a sequence of values ai and a corresponding function f(x, i) that defines the summands from 1 to i, let xi denote a value from 0 to ai-1 such that ansi = xi * i + k is the part of answer we gain from summands from 1 to i, where k is a constant. We can define a dynamic programming (dp) solution in O(n2) to find the maximum answer by keeping only one triple (i, r, k) with equal i and r and the largest k, as well as a maximum of i such triples on step i, and merging those with r = ai + 1 - 1. Additionally, we can note that if r < ai + 1, we can just leave a triple (i, r, k) untouched except changing i to i + 1. To speed this up, we can note that a number can only be taken by modulo  times until it becomes zero, where C is the bound of its initial value, and using this fact, the total number of times we touch a pair is bounded by  and the complexity by ."}}, {"name": "The Three Little Pigs", "code": ["1548", "C"], "tags": ["combinatorics", "dp", "fft", "math"], "difficulty": 2500, "statement": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the $$$n$$$-th minute, the convention ends.The big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly $$$x$$$ pigs. Then he will get away.The wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly $$$x$$$ pigs for various values of $$$x$$$ ($$$1 \\le x \\le 3n$$$). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.Note that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!", "editorial": "For a given $$$x$$$, we want to compute $$$\\sum_{i=1}^{N},{\\binom{3i},{x}}$$$, which can be solved with a combinatorial dynamic programming.Define the array $$$dp[x][m]$$$ (dimensions: $$$N+1\\times 3$$$), which computes the sum $$$\\sum_{i=0}^{N-1},{\\binom{3i+m},{x}}$$$. Under this definition, $$$ans[x]=dp[x][0]+\\binom{3N},{x}$$$, where $$$ans$$$ is what we want to find.Under the definition of the dp, we can make the following mathematical observations.$$$dp[x][0]+dp[x][1]+dp[x][2]=\\sum_{i=0}^{3N-1},{\\binom{i},{x}}$$$, since term $$$i$$$ belongs to the array with $$$m=i\\mod{3}$$$. This summation can be condensed with the Hockey Stick Identity into $$$\\binom{3N},{x+1}$$$.By repeated uses of Pascal's Identity, we get equations (2) and (3), giving us a system of 3 equations with 3 new unknowns, which can easily be solved.  $$$\\sum_{m=0}^{2},{dp[x][m]}=\\binom{3N},{x+1}$$$.  $$$dp[x][1] = dp[x][0]+dp[x-1][0]$$$  $$$dp[x][2] = dp[x][1]+dp[x-1][1]$$$ The base case is that $$$dp[0][0]=dp[0][1]=dp[0][2]=N$$$. Each query can now be answered trivially.The time complexity is $$$\\mathcal{O}(N)$$$ with combinatorial precomputation.ALTERNATE SOLUTION WITH POLYNOMIAL LONG DIVISION:Define the polynomial $$$P(k)=(1+k)^3+(1+k)^6+\\cdot + (1+k)^{3N}$$$.The coefficient of $$$k^x$$$ in $$$P(k)$$$ is, by the Binomial theorem on each term of the polynomial, equal to $$$\\binom{3},{x}+\\binom{6},{x}+\\cdot + \\binom{3N},{x}$$$. This is equal to $$$ans[x]$$$ from the previous solution.The only thing left to do is quickly calculate $$$P(k)$$$. Due to the tight time limit, calculating the polynomial using FFT in $$$\\mathcal{O},{(N\\log{N})}$$$ is probably too slow.Instead, we notice that $$$P(k)$$$ is a geometric series. Using the geometric series formula, we get that $$$P(k)=\\frac{(1+k)^{3N+3}-(1+k)^3},{(1+k)^3-1}$$$.The numerator and denominator of this fraction can be expanded in linear time. Then all we have to do is a polynomial long division. Once we have $$$P(k)$$$, we can answer all the queries trivially.The time complexity is $$$\\mathcal{O}(N)$$$ with combinatorial precomputation.", "simplified": {"statement": "\nGiven an integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$) and an integer $$$x$$$ ($$$1 \\le x \\le 3n$$$), calculate the number of possible attack plans that involve eating exactly $$$x$$$ pigs for various values of $$$x$$$.", "editorial": "\nWe can compute $$$\\sum_{i=1}^{N},{\\binom{3i},{x}}$$$ with a combinatorial dynamic programming approach by defining the array $$$dp[x][m]$$$ (dimensions: $$$N+1\\times 3$$$) and the base case $$$dp[0][0]=dp[0][1]=dp[0][2]=N$$$. Using the Hockey Stick Identity and Pascal's Identity, we get a system of three equations to solve for the unknowns, with a time complexity of $$$\\mathcal{O}(N)$$$. Alternatively, using a polynomial long division, we can calculate the polynomial $$$P(k)$$$, whose coefficient of $$$k^x$$$ is equal to $$$ans[x]$$$, with a time complexity of $$$\\mathcal{O}(N)$$$."}}, {"name": "Array Stabilization", "code": ["1095", "B"], "tags": ["implementation"], "difficulty": 900, "statement": "You are given an array $$$a$$$ consisting of $$$n$$$ integer numbers.Let instability of the array be the following value: $$$\\max\\limits_{i = 1}^{n} a_i - \\min\\limits_{i = 1}^{n} a_i$$$.You have to remove exactly one element from this array to minimize instability of the resulting $$$(n-1)$$$-elements array. Your task is to calculate the minimum possible instability.", "editorial": "It is easy to see that we always have to remove either minimum or maximum of the array. So we can sort the array and the answer will be $$$min(a_{n - 1} - a_{1}, a_{n} - a_{2})$$$. We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time.", "simplified": {"statement": "\nLet $$$a$$$ be an array of $$$n$$$ integers. The minimum possible instability of the resulting $$$(n-1)$$$-elements array can be calculated by finding $$$\\min\\limits_{i = 1}^{n} (\\max\\limits_{j \\neq i} a_j - \\min\\limits_{j \\neq i} a_j)$$$, where $$$a_i$$$ denotes the $$$i$$$-th element of the array.", "editorial": "\nThe answer to the problem is $$$min(a_{n - 1} - a_{1}, a_{n} - a_{2})$$$ where $$$a_1, a_2,...,a_n$$$ are the elements of the array, which can be found in linear time."}}, {"name": "Inconvenient Pairs", "code": ["1569", "D"], "tags": ["binary search", "data structures", "implementation", "sortings", "two pointers"], "difficulty": 1900, "statement": "There is a city that can be represented as a square grid with corner points in $$$(0, 0)$$$ and $$$(10^6, 10^6)$$$.The city has $$$n$$$ vertical and $$$m$$$ horizontal streets that goes across the whole city, i.\u00a0e. the $$$i$$$-th vertical streets goes from $$$(x_i, 0)$$$ to $$$(x_i, 10^6)$$$ and the $$$j$$$-th horizontal street goes from $$$(0, y_j)$$$ to $$$(10^6, y_j)$$$. All streets are bidirectional. Borders of the city are streets as well.There are $$$k$$$ persons staying on the streets: the $$$p$$$-th person at point $$$(x_p, y_p)$$$ (so either $$$x_p$$$ equal to some $$$x_i$$$ or $$$y_p$$$ equal to some $$$y_j$$$, or both).Let's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.Calculate the number of inconvenient pairs of persons (pairs $$$(x, y)$$$ and $$$(y, x)$$$ are the same pair).Let's recall that Manhattan distance between points $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ is $$$|x_1 - x_2| + |y_1 - y_2|$$$.", "editorial": "Firstly, let's look at some point $$$(x_i, y_i)$$$. Let's find closest to it vertical and horizontal lines. We will name the closest vertical lines from left and right as $$$lx$$$ and $$$rx$$$ (and $$$ly$$$ and $$$ry$$$ as closest horizontal lines). So, $$$lx \\le x \\le rx$$$ and $$$ly \\le y \\le ry$$$ (we can also note that either $$$lx = rx$$$ or $$$ly = ry$$$).Now, let's note that if for some other point $$$j$$$ $$$(x_j, y_j)$$$ either $$$lx < x_j < rx$$$ or $$$ly < y_j < ry$$$ then to reach $$$j$$$ from $$$i$$$ we must go reach either $$$lx$$$ or $$$rx$$$ (or, $$$ly$$$ or $$$ry$$$), so the shortest distance will be strictly greater than the Manhattan distance. If neither $$$lx < x_j < rx$$$ nor $$$ly < y_j < ry$$$, then we can show that it's always possible to find the shortest path equal to the Manhattan distance. As a result, for each point $$$(x_i, y_i)$$$ we should find the number of points $$$(x_j, y_j)$$$ such that $$$j < i$$$ and $$$lx < x_j < rx$$$ or $$$ly < y_j < ry$$$. The exception here is when $$$j$$$ lies on the same line as $$$i$$$, so we should not count such points.We can note that since either $$$lx = rx$$$ or $$$ly = ry$$$ there is no such point $$$j$$$ that $$$lx < x_j < rx$$$ and $$$ly < y_j < ry$$$ simultaneously, so we can calculate the pairs by $$$x$$$ and $$$y$$$ coordinates independently.Let's focus on $$$y$$$ coordinates (to calculate for $$$x$$$ coordinates, we can just swap all coordinates). Let's sort all points by $$$x$$$ coordinate. To get rid of the case when points $$$i$$$ and $$$j$$$ lies on the same vertical street, we can group them by $$$x$$$ coordinate and process by group (since we sorted by $$$x$$$, groups are just segments). There are no problems with the case when points lie on the same horizontal street, since then $$$ly = ry$$$ and there are no other $$$y_j$$$ with $$$ly < y_j < ry$$$.If we store for each horizontal line $$$y_j$$$ the number of point inside the interval $$$(y_i, y_{i + 1})$$$ then, when we need for point $$$i$$$ calculate the number of points $$$j$$$ with $$$j < i$$$ and $$$ly < y_j < ry$$$, we can just ask for value assigned to $$$ly$$$, because $$$ly$$$ and $$$ry$$$ are consecutive elements in the array $$$y$$$.So, we go through each group two times: first collecting answer, then updating values in appropriate $$$ly$$$-s. Note, that we can calculate $$$ly$$$ and $$$ry$$$ with binary search (using built-in functions).The resulting complexity is $$$O(n + m + k (\\log{k} + \\log{n} + \\log{m}))$$$.", "simplified": {"statement": "\nGiven $$$n$$$,$$$m$$$,$$$k$$$, $$$x_i$$$, $$$y_j$$$, $$$x_p$$$, and $$$y_p$$$ for $$$1 \\le i \\le n$$$, $$$1 \\le j \\le m$$$, and $$$1 \\le p \\le k$$$, the number of inconvenient pairs of persons is the number of pairs $$$(p_1, p_2)$$$ out of $$$k^2$$$ possible pairs such that the Manhattan distance between $$$(x_{p_1}, y_{p_1})$$$ and $$$(x_{p_2}, y_{p_2})$$$ is strictly greater than the shortest path from one person to another going only by streets.", "editorial": "\nGiven a set of points $$$\\{(x_i, y_i)\\}$$$, we can determine the number of points $$$(x_j, y_j)$$$ such that $$$j < i$$$ and $$$lx < x_j < rx$$$ or $$$ly < y_j < ry$$$, by sorting points by $$$x$$$ coordinate and grouping them into segments, then for each point finding the lines $$$lx$$$, $$$rx$$$, $$$ly$$$, and $$$ry$$$ that bound it with a binary search, and then storing and updating the number of points in each interval of $$$y$$$-coordinates. This can be accomplished in $$$O(n + m + k (\\log{k} + \\log{n} + \\log{m}))$$$ time complexity, where $$$n= |\\{x_i\\}|, m= |\\{y_i\\}|, k= |\\{x_i, y_i\\}|$$$."}}, {"name": "Nauuo and Chess", "code": ["1173", "B"], "tags": ["constructive algorithms", "greedy"], "difficulty": 1100, "statement": "Nauuo is a girl who loves playing chess.One day she invented a game by herself which needs $$$n$$$ chess pieces to play on a $$$m\\times m$$$ chessboard. The rows and columns are numbered from $$$1$$$ to $$$m$$$. We denote a cell on the intersection of the $$$r$$$-th row and $$$c$$$-th column as $$$(r,c)$$$.The game's goal is to place $$$n$$$ chess pieces numbered from $$$1$$$ to $$$n$$$ on the chessboard, the $$$i$$$-th piece lies on $$$(r_i,\\,c_i)$$$, while the following rule is satisfied: for all pairs of pieces $$$i$$$ and $$$j$$$, $$$|r_i-r_j|+|c_i-c_j|\\ge|i-j|$$$. Here $$$|x|$$$ means the absolute value of $$$x$$$.However, Nauuo discovered that sometimes she couldn't find a solution because the chessboard was too small.She wants to find the smallest chessboard on which she can put $$$n$$$ pieces according to the rules.She also wonders how to place the pieces on such a chessboard. Can you help her?", "editorial": "1. $$$m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$Consider the chess pieces $$$1$$$ and $$$n$$$.$$$\\because\\begin{cases}|r_1-r_n|+|c_1-c_n|\\ge n-1\\\\|r_1-r_n|\\le m-1\\\\|c_1-c_n|\\le m-1\\end{cases}$$$$$$\\therefore m-1+m-1\\ge n-1$$$$$$\\therefore m\\ge\\frac{n+1}2$$$$$$\\because m\\text{ is an integer}$$$$$$\\therefore m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$2. $$$m$$$ can be $$$\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$If we put the $$$i$$$-th piece on $$$(r_i,c_i)$$$ satisfying $$$r_i+c_i=i+1$$$, it is a feasible plan, because $$$|r_i-r_j|+|c_i-c_j|\\ge|r_i+c_i-r_j-c_j|$$$.", "simplified": {"statement": "\nGiven a positive integer $$$n$$$, the problem is to find the smallest positive integer $$$m$$$ such that there is a valid placement of $$$n$$$ pieces on a $$$m \\times m$$$ chessboard where the $$$i$$$-th piece is placed at cell $$$(r_i, c_i)$ such that $$$|r_i-r_j|+|c_i-c_j|\\ge|i-j|$$$ holds for all $$$1 \\le i, j \\le n$$$.", "editorial": "\nGiven $$$m$$$ chess pieces and $$$n$$$ cells, where $$$m$$$ can range from $$$1$$$ to $$$n$$$, it is necessary that $$$m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$ in order for the pieces to occupy all cells. This is because $$$|r_1-r_n|+|c_1-c_n|\\ge n-1$$$, where $$$(r_i, c_i)$$$ is the coordinates of the $$$i$$$-th chess piece, and $$$|r_1-r_n|\\le m-1$$$ and $$$|c_1-c_n|\\le m-1$$$."}}]