[{"name": "Mod Mod Mod", "code": ["889", "E"], "tags": ["binary search", "dp", "math"], "difficulty": 3000, "statement": "You are given a sequence of integers a1, a2, ..., an. Let , and  for 1 \u2264 i < n. Here,  denotes the modulus operation. Find the maximum value of f(x, 1) over all nonnegative integers x. ", "editorial": "Hint 1: let . Can you define some interesting segments of value xi?Hint 2: think of some dp.Hint 3: once you get the dp in O(n2), to speed it up, note the following fact: if , then either c = a or .Explanation of hint 1: let's call ansi = f(x, 1) - f(xi, i + 1), in other words, it's the part of answer we gain from summands from 1 to i. For i = 1 the following is true: x1 can be any number from 0 to a1 - 1, and ansi = xi.Suppose for some i we have the following option: xi can be any number from 0 to r, and in this case ansi = xi * i + k. We can describe this situation by triple (i, r, k). We will show that this triple will produce at most two such triples for i + 1. Indeed, we can have many triples (i + 1, ai + 1 - 1, kj) with different kj and one triple . However, we can note that among triplets of the first type we can leave only one with maximum kj, because we're interested in maximum answer. This kj will equal . Thus, we have two transitions from each triple, that leads us to O(2n) bruteforce solution.Explanation of hint 2: when we have a bruteforce, we (almost) always can think of a dp. Indeed, we have triples, among those with equal i and r let's keep only one with the largest k. There are at most i such triples on step i: on each step half of the generated triples have r = ai + 1 - 1, so we can merge them. This leads us to dp in O(n2).Explanation of hint 3: Okay, what does the third hint say? It basically says that a number can only be taken by modulo  times until it becomes zero, where C is the bound of its initial value. What do we get from this? We can note that if r < ai + 1, we can just leave a triple (i, r, k) untouched except changing i to i + 1. Let's then keep pairs (r, k), assuming triples (i, r, k), where i changes in a cycle. On each step we should change all pairs such that r \u2265 ai + 1, possibly adding one more pair with r = ai + 1 - 1. But when we change a pair, r is get by modulo, so this won't happen with a pair more than O(log(C)) times! Overall, the total number of times we touch a pair is bounded by . Adding  for map in which we keeps the pairs, we obtain the final complexity . Also, map can be replaced with binary search, but the complexity remains the same.", "simplified": {"statement": "\nFind max {f(x,1) | x \u2208 \u2124, x \u2265 0}, where f(x, y) = (a1 + a2 y + ... + an yn-1) mod n for all integers x, y \u2265 0.", "editorial": "\nLet f(x,i) denote the sum from 1 to i of the values xi. Let ansi denote f(x,1) - f(xi,i+1). We introduce triples (i,r,k) to depict the situation where xi can be any number from 0 to r and ansi = xi * i + k. We can use dynamic programming to calculate the maximum value of ansi, by keeping only the triple with the largest k for each i, and merging any triples that have the same i and r. Since r can only be taken by modulo C times until it becomes zero, where C is the bound of its initial value, we can reduce the complexity to O(n2 + nlog(C))."}}, {"name": "The Three Little Pigs", "code": ["1548", "C"], "tags": ["combinatorics", "dp", "fft", "math"], "difficulty": 2500, "statement": "Three little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the $$$n$$$-th minute, the convention ends.The big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly $$$x$$$ pigs. Then he will get away.The wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly $$$x$$$ pigs for various values of $$$x$$$ ($$$1 \\le x \\le 3n$$$). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.Note that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!", "editorial": "For a given $$$x$$$, we want to compute $$$\\sum_{i=1}^{N},{\\binom{3i},{x}}$$$, which can be solved with a combinatorial dynamic programming.Define the array $$$dp[x][m]$$$ (dimensions: $$$N+1\\times 3$$$), which computes the sum $$$\\sum_{i=0}^{N-1},{\\binom{3i+m},{x}}$$$. Under this definition, $$$ans[x]=dp[x][0]+\\binom{3N},{x}$$$, where $$$ans$$$ is what we want to find.Under the definition of the dp, we can make the following mathematical observations.$$$dp[x][0]+dp[x][1]+dp[x][2]=\\sum_{i=0}^{3N-1},{\\binom{i},{x}}$$$, since term $$$i$$$ belongs to the array with $$$m=i\\mod{3}$$$. This summation can be condensed with the Hockey Stick Identity into $$$\\binom{3N},{x+1}$$$.By repeated uses of Pascal's Identity, we get equations (2) and (3), giving us a system of 3 equations with 3 new unknowns, which can easily be solved.  $$$\\sum_{m=0}^{2},{dp[x][m]}=\\binom{3N},{x+1}$$$.  $$$dp[x][1] = dp[x][0]+dp[x-1][0]$$$  $$$dp[x][2] = dp[x][1]+dp[x-1][1]$$$ The base case is that $$$dp[0][0]=dp[0][1]=dp[0][2]=N$$$. Each query can now be answered trivially.The time complexity is $$$\\mathcal{O}(N)$$$ with combinatorial precomputation.ALTERNATE SOLUTION WITH POLYNOMIAL LONG DIVISION:Define the polynomial $$$P(k)=(1+k)^3+(1+k)^6+\\cdot + (1+k)^{3N}$$$.The coefficient of $$$k^x$$$ in $$$P(k)$$$ is, by the Binomial theorem on each term of the polynomial, equal to $$$\\binom{3},{x}+\\binom{6},{x}+\\cdot + \\binom{3N},{x}$$$. This is equal to $$$ans[x]$$$ from the previous solution.The only thing left to do is quickly calculate $$$P(k)$$$. Due to the tight time limit, calculating the polynomial using FFT in $$$\\mathcal{O},{(N\\log{N})}$$$ is probably too slow.Instead, we notice that $$$P(k)$$$ is a geometric series. Using the geometric series formula, we get that $$$P(k)=\\frac{(1+k)^{3N+3}-(1+k)^3},{(1+k)^3-1}$$$.The numerator and denominator of this fraction can be expanded in linear time. Then all we have to do is a polynomial long division. Once we have $$$P(k)$$$, we can answer all the queries trivially.The time complexity is $$$\\mathcal{O}(N)$$$ with combinatorial precomputation.", "simplified": {"statement": "\nGiven $$$n$$$ and $$$x$$$, where $$$1 \\le x \\le 3n$$$, the number of possible attack plans by the wolf to eat exactly $$$x$$$ pigs can be found by counting the number of combinations of $$$x$$$ out of $$$3n$$$ pigs. This can be calculated using the combination formula $\\binom{3n}{x}$.", "editorial": "\nWe can compute $$$\\sum_{i=1}^{N},{\\binom{3i},{x}}$$$ in $$$\\mathcal{O}(N)$$$ time with combinatorial precomputation by defining the array $$$dp[x][m]$$$ which computes the sum $$$\\sum_{i=0}^{N-1},{\\binom{3i+m},{x}}$$$, and setting $$$ans[x]=dp[x][0]+\\binom{3N},{x}$$$. We can then use the Hockey Stick Identity to reduce the summation to $$$\\binom{3N},{x+1}$$$ and use Pascal's Identity twice to give us a system of 3 equations with 3 new unknowns which can be solved. Alternatively, we can define the polynomial $$$P(k)=(1+k)^3+(1+k)^6+\\cdot + (1+k)^{3N}$$$ and use the Binomial Theorem to calculate $$$ans[x]$$$ as the coefficient of $$$k^x$$$ in $$$P(k)$$$. We can then expand the numerator and denominator of $$$P(k)$$$ in linear time and perform a polynomial long division to answer all queries trivially."}}, {"name": "Array Stabilization", "code": ["1095", "B"], "tags": ["implementation"], "difficulty": 900, "statement": "You are given an array $$$a$$$ consisting of $$$n$$$ integer numbers.Let instability of the array be the following value: $$$\\max\\limits_{i = 1}^{n} a_i - \\min\\limits_{i = 1}^{n} a_i$$$.You have to remove exactly one element from this array to minimize instability of the resulting $$$(n-1)$$$-elements array. Your task is to calculate the minimum possible instability.", "editorial": "It is easy to see that we always have to remove either minimum or maximum of the array. So we can sort the array and the answer will be $$$min(a_{n - 1} - a_{1}, a_{n} - a_{2})$$$. We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time.", "simplified": {"statement": "\nLet $$$a_1, a_2, ..., a_n$$$ be the elements of the array. The minimum possible instability of the array after removing one element is $$$\\min \\left(\\max_{i = 1}^{n} a_i - \\min_{j \\neq i = 1}^{n} a_j, \\max_{j \\neq i = 1}^{n} a_j - \\min_{i = 1}^{n} a_i \\right)$$$.", "editorial": "\nThe minimum difference between two elements in an array of size $n$ can be found by calculating $min(a_{n - 1} - a_{1}, a_{n} - a_{2})$, which can be done in linear time without sorting."}}, {"name": "Inconvenient Pairs", "code": ["1569", "D"], "tags": ["binary search", "data structures", "implementation", "sortings", "two pointers"], "difficulty": 1900, "statement": "There is a city that can be represented as a square grid with corner points in $$$(0, 0)$$$ and $$$(10^6, 10^6)$$$.The city has $$$n$$$ vertical and $$$m$$$ horizontal streets that goes across the whole city, i.\u00a0e. the $$$i$$$-th vertical streets goes from $$$(x_i, 0)$$$ to $$$(x_i, 10^6)$$$ and the $$$j$$$-th horizontal street goes from $$$(0, y_j)$$$ to $$$(10^6, y_j)$$$. All streets are bidirectional. Borders of the city are streets as well.There are $$$k$$$ persons staying on the streets: the $$$p$$$-th person at point $$$(x_p, y_p)$$$ (so either $$$x_p$$$ equal to some $$$x_i$$$ or $$$y_p$$$ equal to some $$$y_j$$$, or both).Let's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.Calculate the number of inconvenient pairs of persons (pairs $$$(x, y)$$$ and $$$(y, x)$$$ are the same pair).Let's recall that Manhattan distance between points $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ is $$$|x_1 - x_2| + |y_1 - y_2|$$$.", "editorial": "Firstly, let's look at some point $$$(x_i, y_i)$$$. Let's find closest to it vertical and horizontal lines. We will name the closest vertical lines from left and right as $$$lx$$$ and $$$rx$$$ (and $$$ly$$$ and $$$ry$$$ as closest horizontal lines). So, $$$lx \\le x \\le rx$$$ and $$$ly \\le y \\le ry$$$ (we can also note that either $$$lx = rx$$$ or $$$ly = ry$$$).Now, let's note that if for some other point $$$j$$$ $$$(x_j, y_j)$$$ either $$$lx < x_j < rx$$$ or $$$ly < y_j < ry$$$ then to reach $$$j$$$ from $$$i$$$ we must go reach either $$$lx$$$ or $$$rx$$$ (or, $$$ly$$$ or $$$ry$$$), so the shortest distance will be strictly greater than the Manhattan distance. If neither $$$lx < x_j < rx$$$ nor $$$ly < y_j < ry$$$, then we can show that it's always possible to find the shortest path equal to the Manhattan distance. As a result, for each point $$$(x_i, y_i)$$$ we should find the number of points $$$(x_j, y_j)$$$ such that $$$j < i$$$ and $$$lx < x_j < rx$$$ or $$$ly < y_j < ry$$$. The exception here is when $$$j$$$ lies on the same line as $$$i$$$, so we should not count such points.We can note that since either $$$lx = rx$$$ or $$$ly = ry$$$ there is no such point $$$j$$$ that $$$lx < x_j < rx$$$ and $$$ly < y_j < ry$$$ simultaneously, so we can calculate the pairs by $$$x$$$ and $$$y$$$ coordinates independently.Let's focus on $$$y$$$ coordinates (to calculate for $$$x$$$ coordinates, we can just swap all coordinates). Let's sort all points by $$$x$$$ coordinate. To get rid of the case when points $$$i$$$ and $$$j$$$ lies on the same vertical street, we can group them by $$$x$$$ coordinate and process by group (since we sorted by $$$x$$$, groups are just segments). There are no problems with the case when points lie on the same horizontal street, since then $$$ly = ry$$$ and there are no other $$$y_j$$$ with $$$ly < y_j < ry$$$.If we store for each horizontal line $$$y_j$$$ the number of point inside the interval $$$(y_i, y_{i + 1})$$$ then, when we need for point $$$i$$$ calculate the number of points $$$j$$$ with $$$j < i$$$ and $$$ly < y_j < ry$$$, we can just ask for value assigned to $$$ly$$$, because $$$ly$$$ and $$$ry$$$ are consecutive elements in the array $$$y$$$.So, we go through each group two times: first collecting answer, then updating values in appropriate $$$ly$$$-s. Note, that we can calculate $$$ly$$$ and $$$ry$$$ with binary search (using built-in functions).The resulting complexity is $$$O(n + m + k (\\log{k} + \\log{n} + \\log{m}))$$$.", "simplified": {"statement": "\nGiven $$$n$$$, $$$m$$$, $$$k$$$, $$$x_i$$$, $$$x_p$$$, $$$y_j$$$, and $$$y_p$$$ for $$$i \\in \\{1, \\dots, n\\}$$$, $$$j \\in \\{1, \\dots, m\\}$$$, and $$$p \\in \\{1, \\dots, k\\}$$$, the number of inconvenient pairs of persons is equal to the number of pairs of distinct persons $$$(x_a, y_a)$$$, $$$(x_b, y_b)$$$ such that $$$|x_a - x_b| + |y_a - y_b| > max(|x_a - x_b|, |y_a - y_b|)$$$.", "editorial": "\nWe can find the shortest path from point $(x_i, y_i)$ to every other point $(x_j, y_j)$ by finding the closest vertical and horizontal lines, $lx, rx, ly, ry$, with $lx \\le x \\le rx$ and $ly \\le y \\le ry$ (either $lx = rx$ or $ly = ry$). We can sort all points by $x$ coordinate, and for each point calculate the number of points $j < i$ with $ly < y_j < ry$ by asking for the value assigned to $ly$, with binary search. The resulting complexity is $O(n + m + k (\\log{k} + \\log{n} + \\log{m}))$, where $k$ is the number of points, $n$ is the number of vertical lines and $m$ is the number of horizontal lines."}}, {"name": "Nauuo and Chess", "code": ["1173", "B"], "tags": ["constructive algorithms", "greedy"], "difficulty": 1100, "statement": "Nauuo is a girl who loves playing chess.One day she invented a game by herself which needs $$$n$$$ chess pieces to play on a $$$m\\times m$$$ chessboard. The rows and columns are numbered from $$$1$$$ to $$$m$$$. We denote a cell on the intersection of the $$$r$$$-th row and $$$c$$$-th column as $$$(r,c)$$$.The game's goal is to place $$$n$$$ chess pieces numbered from $$$1$$$ to $$$n$$$ on the chessboard, the $$$i$$$-th piece lies on $$$(r_i,\\,c_i)$$$, while the following rule is satisfied: for all pairs of pieces $$$i$$$ and $$$j$$$, $$$|r_i-r_j|+|c_i-c_j|\\ge|i-j|$$$. Here $$$|x|$$$ means the absolute value of $$$x$$$.However, Nauuo discovered that sometimes she couldn't find a solution because the chessboard was too small.She wants to find the smallest chessboard on which she can put $$$n$$$ pieces according to the rules.She also wonders how to place the pieces on such a chessboard. Can you help her?", "editorial": "1. $$$m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$Consider the chess pieces $$$1$$$ and $$$n$$$.$$$\\because\\begin{cases}|r_1-r_n|+|c_1-c_n|\\ge n-1\\\\|r_1-r_n|\\le m-1\\\\|c_1-c_n|\\le m-1\\end{cases}$$$$$$\\therefore m-1+m-1\\ge n-1$$$$$$\\therefore m\\ge\\frac{n+1}2$$$$$$\\because m\\text{ is an integer}$$$$$$\\therefore m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$2. $$$m$$$ can be $$$\\left\\lfloor\\frac n 2\\right\\rfloor+1$$$If we put the $$$i$$$-th piece on $$$(r_i,c_i)$$$ satisfying $$$r_i+c_i=i+1$$$, it is a feasible plan, because $$$|r_i-r_j|+|c_i-c_j|\\ge|r_i+c_i-r_j-c_j|$$$.", "simplified": {"statement": "\nGiven $$$n$$$ chess pieces and a rule that for all pairs of pieces $$$i$$$ and $$$j$$$, $$$|r_i-r_j|+|c_i-c_j|\\ge|i-j|$$$, where $$$r_i$$$ and $$$c_i$$$ are the row and column of the $$$i$$$-th piece, respectively, the problem is to find the minimum $$$m \\in \\mathbb{N}$$$ such that $$$n$$$ pieces can be placed on a $$$m\\times m$$$ chessboard satisfying the rule.", "editorial": "\nFor two chess pieces with indices $1$ and $n$, we require that $m \\ge \\left\\lfloor\\frac n 2\\right\\rfloor+1$, where $m$ is the number of rows or columns for the chessboard, such that if piece $i$ is placed on $(r_i,c_i)$ with $r_i + c_i = i + 1$, then $|r_i-r_j|+|c_i-c_j| \\ge |r_i + c_i - r_j - c_j|$ holds for all $i,j$."}}, {"name": "CQXYM Count Permutations", "code": ["1581", "A"], "tags": ["combinatorics", "math", "number theory"], "difficulty": 800, "statement": "CQXYM is counting permutations length of $$$2n$$$.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).A permutation $$$p$$$(length of $$$2n$$$) will be counted only if the number of $$$i$$$ satisfying $$$p_i<p_{i+1}$$$ is no less than $$$n$$$. For example:  Permutation $$$[1, 2, 3, 4]$$$ will count, because the number of such $$$i$$$ that $$$p_i<p_{i+1}$$$ equals $$$3$$$ ($$$i = 1$$$, $$$i = 2$$$, $$$i = 3$$$). Permutation $$$[3, 2, 1, 4]$$$ won't count, because the number of such $$$i$$$ that $$$p_i<p_{i+1}$$$ equals $$$1$$$ ($$$i = 3$$$). CQXYM wants you to help him to count the number of such permutations modulo $$$1000000007$$$ ($$$10^9+7$$$).In addition, modulo operation is to get the remainder. For example:  $$$7 \\mod 3=1$$$, because $$$7 = 3 \\cdot 2 + 1$$$,  $$$15 \\mod 4=3$$$, because $$$15 = 4 \\cdot 3 + 3$$$. ", "editorial": "Let's define $$$q$$$ as the number of $$$i$$$ satisfying the condition. Since the length of the permutation is an even number, the number of permutations which $$$q \\geq n$$$ is equal to the ones which $$$q < n$$$. So the answer is $$$\\frac{1},{2}(2n!)$$$ and the complexity is $$$O(n)$$$.to calculate it in with modulo - just calc $$$(2n-1)! \\cdot n$$$", "simplified": {"statement": "\nCQXYM wishes to count the number of permutations of length $$$2n$$$, consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$, such that the number of $$$i$$$ satisfying $$$p_i<p_{i+1}$$$ is no less than $$$n$$$, modulo $$$1000000007$$$ ($$$10^9+7$$$).", "editorial": "\nThe number of permutations of length $$$2n$$$ where the number of $$$i$$$ satisfying the condition is $$$q$$$ is given by $\\frac{1}{2}(2n!)$, and can be calculated in $$$O(n)$$$ time using the formula $(2n-1)! \\cdot n$."}}, {"name": "Coffee and Coursework (Hard Version)", "code": ["1118", "D2"], "tags": ["binary search", "greedy"], "difficulty": 1700, "statement": "The only difference between easy and hard versions is the constraints.Polycarp has to write a coursework. The coursework consists of $$$m$$$ pages.Polycarp also has $$$n$$$ cups of coffee. The coffee in the $$$i$$$-th cup Polycarp has $$$a_i$$$ caffeine in it. Polycarp can drink some cups of coffee (each one no more than once). He can drink cups in any order. Polycarp drinks each cup instantly and completely (i.e. he cannot split any cup into several days).Surely, courseworks are not being written in a single day (in a perfect world of Berland, at least).Let's consider some day of Polycarp's work. Consider Polycarp drinks $$$k$$$ cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are $$$a_{i_1}, a_{i_2}, \\dots, a_{i_k}$$$. Then the first cup he drinks gives him energy to write $$$a_{i_1}$$$ pages of coursework, the second cup gives him energy to write $$$max(0, a_{i_2} - 1)$$$ pages, the third cup gives him energy to write $$$max(0, a_{i_3} - 2)$$$ pages, ..., the $$$k$$$-th cup gives him energy to write $$$max(0, a_{i_k} - k + 1)$$$ pages.If Polycarp doesn't drink coffee during some day, he cannot write coursework at all that day.Polycarp has to finish his coursework as soon as possible (spend the minimum number of days to do it). Your task is to find out this number of days or say that it is impossible.", "editorial": "Well, the main idea is described in the previous (D1) problem editorial. Read it firstly.So, now we have to improve our solution somehow. How can we do it? Wait... What is it? We iterate over all numbers of days... And the number of pages Polycarp can write when we consider $$$k+1$$$ days instead of $$$k$$$ is strictly increases... (because we always can drink any cup even with the minimum value of $$$a_i$$$ as a first during the new day, and the number of pages will increase). So, what is it? Oh, this is binary search!So all we need is to replace linear search to binary search, submit the written code and get AC.", "simplified": {"statement": "\nFor a given set of $$$m$$$ pages and $$$n$$$ cups of coffee with respective caffeine levels $$$a_i$$$, Polycarp must determine the minimum number of days it will take to write the coursework if he drinks the coffee in any order, drinking each cup instantly and completely. He can drink a cup no more than once and will write $$$a_{i_1}$$$ pages the first day, $$$\\text{max}(0, a_{i_2} - 1)$$$ pages the second day, and so on, and will not write any pages if he does not drink coffee on a given day. If it is impossible for Polycarp to complete the coursework, the solution will be to say so.", "editorial": "\nWe can improve our solution by applying binary search to iterate over the number of days needed to write a given number of pages. This will increase the number of pages written by considering larger $$$k+1$$$ instead of $$$k$$$ as we can always drink any cup as a first on the new day."}}, {"name": "Lost Tree", "code": ["1534", "D"], "tags": ["constructive algorithms", "interactive", "trees"], "difficulty": 1800, "statement": "This is an interactive problem.Little Dormi was faced with an awkward problem at the carnival: he has to guess the edges of an unweighted tree of $$$n$$$ nodes! The nodes of the tree are numbered from $$$1$$$ to $$$n$$$.The game master only allows him to ask one type of question: Little Dormi picks a node $$$r$$$ ($$$1 \\le r \\le n$$$), and the game master will reply with an array $$$d_1, d_2, \\ldots, d_n$$$, where $$$d_i$$$ is the length of the shortest path from node $$$r$$$ to $$$i$$$, for all $$$1 \\le i \\le n$$$.Additionally, to make the game unfair challenge Little Dormi the game master will allow at most $$$\\lceil\\frac{n},{2}\\rceil$$$ questions, where $$$\\lceil x \\rceil$$$ denotes the smallest integer greater than or equal to $$$x$$$.Faced with the stomach-churning possibility of not being able to guess the tree, Little Dormi needs your help to devise a winning strategy!Note that the game master creates the tree before the game starts, and does not change it during the game.", "editorial": "If we had $$$n$$$ queries, solving this problem would be easy as we could just query every single node and add edges when $$$d_i=1$$$. However, notice that as long as we make a query for at least $$$1$$$ endpoint of every edge, we will be able to find all the edges using this method.Observe that a tree is bipartite, so we would be able to achieve a bound of $$$\\lceil \\frac{n},{2} \\rceil$$$ as long as we only query the smaller bipartite set. To figure out which set is smaller, we can just query any node and look at which nodes have odd depth and which ones have even depth.Lastly, be careful with your queries so that your worst-case bound is $$$\\lceil \\frac{n},{2} \\rceil$$$ rather than $$$\\lfloor \\frac{n},{2} \\rfloor + 1$$$. One way to do this is to not include the initial node you query in either bipartite set (so you are effectively working with $$$n-1$$$ nodes rather than $$$n$$$).Time complexity: $$$\\mathcal{O}(n^2)$$$", "simplified": {"statement": "\nLittle Dormi needs to devise a strategy to guess the edges of a tree of $$$n$$$ nodes, numbered from $$$1$$$ to $$$n$$$. To help him, the game master will answer one type of question; given a node $$$r$$$, the game master will respond with an array $$$d_1, d_2, \\ldots, d_n$$$ where $$$d_i$$$ is the length of the shortest path from node $$$r$$$ to $$$i$$$. The game master will only allow up to $$$\\lceil\\frac{n},{2}\\rceil$$$ questions.", "editorial": "\nGiven $$$n$$$ nodes and queries, the problem can be solved by querying the smaller bipartite set of nodes and adding edges when $$$d_i=1$$$. The number of queries needed is $$$\\lceil \\frac{n},{2} \\rceil$$$ with worst-case time complexity of $$$\\mathcal{O}(n^2)$$$ if the initial node queried is not included in the bipartite set."}}, {"name": "River Locks", "code": ["1700", "D"], "tags": ["binary search", "dp", "greedy", "math"], "difficulty": 1900, "statement": "Recently in Divanovo, a huge river locks system was built. There are now $$$n$$$ locks, the $$$i$$$-th of them has the volume of $$$v_i$$$ liters, so that it can contain any amount of water between $$$0$$$ and $$$v_i$$$ liters. Each lock has a pipe attached to it. When the pipe is open, $$$1$$$ liter of water enters the lock every second.The locks system is built in a way to immediately transfer all water exceeding the volume of the lock $$$i$$$ to the lock $$$i + 1$$$. If the lock $$$i + 1$$$ is also full, water will be transferred further. Water exceeding the volume of the last lock pours out to the river.   The picture illustrates $$$5$$$ locks with two open pipes at locks $$$1$$$ and $$$3$$$. Because locks $$$1$$$, $$$3$$$, and $$$4$$$ are already filled, effectively the water goes to locks $$$2$$$ and $$$5$$$. Note that the volume of the $$$i$$$-th lock may be greater than the volume of the $$$i + 1$$$-th lock.To make all locks work, you need to completely fill each one of them. The mayor of Divanovo is interested in $$$q$$$ independent queries. For each query, suppose that initially all locks are empty and all pipes are closed. Then, some pipes are opened simultaneously. For the $$$j$$$-th query the mayor asks you to calculate the minimum number of pipes to open so that all locks are filled no later than after $$$t_j$$$ seconds.Please help the mayor to solve this tricky problem and answer his queries. ", "editorial": "To begin with, we note that it makes sense to open only some pipe prefix, because we need to fill all the locks, and more left pipes affect the total volume of the baths, which is obviously beneficial. Let's enumerate how many pipes we will open, namely which prefix of pipes we will open and calculate $$$dp_i$$$ - how long it will take to fill the first $$$i$$$ locks if the first $$$i$$$ pipes are open. Let's introduce an auxiliary array $$$pref_i$$$ - the sum of the capacities of the gateways on the prefix $$$i$$$. Then $$$dp_i = max(dp_{i - 1},\\ \\lceil pref_i / i \\rceil)$$$. Let's see why this is so. We need all gateways on prefix $$$i - 1$$$ to be filled, and also that the $$$i$$$-th gateway be filled. Note that if the $$$i$$$-th gateway does not have time to fill up in the time $$$dp_{i - 1}$$$, then it will fill up in the time $$$\\lceil pref_i / i \\rceil$$$ (filling will occur at the time $$$pref_i / i$$$, but since in the condition we are asked about integer times, we can round up and not use real arithmetic), it turns out when the required amount of water is poured into all the locks in total from all pipes. Now knowing $$$dp_i$$$ for all $$$i$$$ open we can similarly calculate when all n gateways are full. For $$$i$$$ this will be $$$max(dp_i,\\ \\lceil pref_n / i \\rceil)$$$. It is also obvious that when an additional pipe is opened, the time will not increase, therefore we can do a bin search by time and find out the answer for the desired request. If the request $$$t$$$ is less than the minimum filling time for the locks (when all pipes are open), then you need to print $$$-1$$$. Total running time O($$$n + q log(n)$$$).", "simplified": {"statement": "\nGiven $$$n$$$ locks with volumes $$$v_1, v_2, \\dots, v_n$$$, find the minimum number of pipes to open such that all locks are filled within $$$t_1, t_2, \\dots, t_q$$$ seconds.", "editorial": "\nLet $$$dp_i$$$ denote the time required to fill the first $$$i$$$ locks if the first $$$i$$$ pipes are open, and let $$$pref_i$$$ denote the sum of the capacities of the gateways on the prefix $$$i$$$. Then, $$$dp_i = \\max(dp_{i - 1},\\ \\lceil \\frac{pref_i}{i} \\rceil)$$$. We can do a binary search to find the minimum time $$$t$$$ for the desired request. The running time is $$$O(n + q \\log(n))$$$."}}, {"name": "Credit Card", "code": ["893", "D"], "tags": ["data structures", "dp", "greedy", "implementation"], "difficulty": 1900, "statement": "Recenlty Luba got a credit card and started to use it. Let's consider n consecutive days Luba uses the card.She starts with 0 money on her account.In the evening of i-th day a transaction ai occurs. If ai > 0, then ai bourles are deposited to Luba's account. If ai < 0, then ai bourles are withdrawn. And if ai = 0, then the amount of money on Luba's account is checked.In the morning of any of n days Luba can go to the bank and deposit any positive integer amount of burles to her account. But there is a limitation: the amount of money on the account can never exceed d.It can happen that the amount of money goes greater than d by some transaction in the evening. In this case answer will be \u00ab-1\u00bb.Luba must not exceed this limit, and also she wants that every day her account is checked (the days when ai = 0) the amount of money on her account is non-negative. It takes a lot of time to go to the bank, so Luba wants to know the minimum number of days she needs to deposit some money to her account (if it is possible to meet all the requirements). Help her!", "editorial": "The following greedy solution works. Firstly, deposite money only on days with ai = 0. Secondly, every time the balance is negative to the day with ai = 0, refill it to maximal possible value such that it won't go over d later.   Days with ai \u2260 0 can only lead to invalid state by going over card limit. We can only add money to the balance. Adding zero money in those days won't make invalid states if all were valid previously. Finally, if it's possible to get valid state in every day then it's possible to get it by refilling the same day the check happens. For example, you can make max(0, currentBalance) balance in those days. Then you will never have negative balance there. Though it's not the most optimal way.  Let delta be some value you deposite in some day with ai = 0 to pass all conditions till the next day with aj = 0. I state that function of number of game's moves dependancy on delta is monotonious. Let's check it for some fixed x. Define minimum balance you will get on any suffix from now as minBal. Obviously, taking x - 1 will make it minBal - 1. If it goes negative then you will need an extra move to finish the game. Thus taking maximal delta will lead to the lowest score possible. And last but not least \u2014 realization part. What will be the maximum possible value to deposite? Actually, it's such a value that optimal game after this will lead to maximum balance of d in some day. Thus, you want to check what will be the maximum balance maxBal if you add zero money and take delta as d - maxBal. Obviously, if it's negative then output  - 1. Naively this still works on O(n) per day and lead to O(n2) overall. Notice that by depositing delta you increase maximums on each suffix for now by delta. So, you can calculate it as you will do nothing and add sum deltaSum of your delta's to get actual value. You store prefix sum of aj up to i in pri. Then take maximum on suffix for every i (sui is the maxumum prj for j from i to n). delta = d - (deltaSum + sui).I hope I made it clear enough. :DOverall comlpexity: O(n).", "simplified": {"statement": "\nGiven non-negative integers n, d and integers ai for i from 1 to n, find the minimum number of days that Luba needs to deposit some money to her account such that the amount of money on her account is non-negative and does not exceed d, or -1 if it is not possible.", "editorial": "\nGiven a sequence of numbers a1, a2, ..., an and a given limit d, the minimum number of moves to reach a valid state can be calculated in O(n) time by first depositing money only on days with ai = 0 and refilling the balance to the maximal possible value such that it won't go over d later on days with ai \u2260 0, then calculating the maximum value of delta such that the maximum balance is d on some day, and finally calculating the prefix sum of aj up to i and taking the maximum on the suffix for every i and adding the sum of delta's to get the actual value."}}, {"name": "Match Points", "code": ["1156", "C"], "tags": ["binary search", "greedy", "sortings", "ternary search", "two pointers"], "difficulty": 2000, "statement": "You are given a set of points $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ on the number line.Two points $$$i$$$ and $$$j$$$ can be matched with each other if the following conditions hold:  neither $$$i$$$ nor $$$j$$$ is matched with any other point;  $$$|x_i - x_j| \\ge z$$$. What is the maximum number of pairs of points you can match with each other?", "editorial": "Let's denote the points that have greater coordinates in their matched pairs as $$$R$$$-points, and the points that have smaller coordinates as $$$L$$$-points.Suppose we have an $$$R$$$-point that has smaller coordinate than some $$$L$$$-point. Then we can \"swap\" them, and the answer won't become worse. Also, if some $$$R$$$-point has smaller coordinate than some point that doesn't belong to any pair, or some $$$L$$$-point has greater coordinate than some point that doesn't belong to any pair, we can swap them too. So, if the answer is $$$k$$$, we choose $$$k$$$ leftmost points as $$$L$$$-points, and $$$k$$$ rightmost ones as $$$R$$$-points.For a fixed value of $$$k$$$, it's easy to see that we should match the leftmost $$$L$$$-point with the leftmost $$$R$$$-point, the second $$$L$$$-point with the second $$$R$$$-point, and so on, in order to maximize the minimum distance in a pair. This fact allows us to check whether it is possible to construct at least $$$k$$$ pairs, and we can use binary search to compute the answer to the problem.", "simplified": {"statement": "\nGiven a set of $$$n$$$ points $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ on the number line, the maximum number of pairs of points that can be matched with each other such that $$$|x_i - x_j| \\ge z$$$ for all matched points $$$i$$$ and $$$j$$$ is the maximum cardinality of a subset of points such that for all pairs $$$i$$$ and $$$j$$$, $$$|x_i - x_j| \\ge z$$$.", "editorial": "\nGiven a set of $$$2N$$$ points, $$\\{(x_1, y_1), \\dots, (x_{2N}, y_{2N})\\},$$ to find the least value of $$$k$$$ for which there exists a matching of $$$k$$$ pairs of points with maximum pairwise distance $$$d_k$$$, denoted as $$\\{(x_i, y_i), (x_j, y_j)\\} \\in \\mathcal{P}_k$$, we can define the points with greater coordinates in their matched pairs as $$$R$$$-points and the points with smaller coordinates as $$$L$$$-points. We can then swap any $$$R$$$-point with a smaller coordinate than an $$$L$$$-point, or any $$$R$$$-point with a smaller coordinate than a point that does not belong to a pair, or any $$$L$$$-point with a greater coordinate than a point that does not belong to a pair, to create a new matching of $$$k$$$ pairs with maximum pairwise distance $$$d_k$$$. Using binary search, we can compute the least value of $$$k$$$ for which such a matching exists, and for a fixed value of $$$k$$$ match the leftmost $$$L$$$-point with the leftmost $$$R$$$-point, the second $$$L$$$-point with the second $$$R$$$-point, and so on, to maximize the minimum distance in a pair."}}]